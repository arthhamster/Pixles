<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Moddery Image Editor</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@1.0.4/css/bulma.min.css">
<link rel="stylesheet" href="https://ejd799.github.io/BulmaColoredInputs/main.css">
<link rel="stylesheet" href="../styles.css">
<style id="themeStyleElement"></style>
<style>
html, body {
    margin: 0; padding: 0; height: 100%;
    font-family: Verdana, sans-serif; background: var(--app-main-tabs-background); color: var(--bulma-text);
    display: flex; flex-direction: column;
}
#toolbar {
    display: flex;
    gap: 4px;
    padding: 4px;
    align-items: center;
    flex-wrap: wrap;
    background: var(--app-image-editor-toolbar-background);
}

#canvasContainer {
    flex: 1; position: relative; overflow: hidden; background: var(--app-image-editor-background);
    display: flex; justify-content: center; align-items: center; cursor: crosshair;
}
canvas { image-rendering: pixelated; display: block; }

#toolbar button {
    text-align: center;
    padding-right: 12px;
}

#colorPicker {
  appearance: none;
  -webkit-appearance: none;
  border: none;
  background: none;
  padding: 0;
  width: 28px;
  height: 20px;
  cursor: pointer;
  vertical-align: middle;
}

/* Chrome / Edge / Safari */
#colorPicker::-webkit-color-swatch-wrapper {
  padding: 0;
}

#colorPicker::-webkit-color-swatch {
  border: none;
  border-radius: 4px; /* optional */
}

/* Firefox */
#colorPicker::-moz-color-swatch {
  border: none;
  border-radius: 4px; /* optional */
}

/* Optional Bulma-style affordances */
#colorPicker:hover {
  outline: 1px solid var(--bulma-border);
}

#colorPicker:focus-visible {
  outline: 2px solid var(--bulma-link);
  outline-offset: 2px;
}

</style>
</head>
<body>

<div id="toolbar">
    <div class="field has-addons">
        <p class="control"><button title="Move" class="button" id="toolMove"><i class="fas fa-arrows-alt"></i></button></p>
        <p class="control"><button title="Brush" class="button is-link" id="toolPencil"><i class="fas fa-paintbrush"></i></button></p>
        <p class="control"><button title="Rectangle" class="button" id="toolRect"><i class="fas fa-square"></i></button></p>
        <p class="control"><button title="Fill" class="button" id="toolFill"><i class="fas fa-fill-drip"></i></button></p>
        <p class="control"><button title="Eraser" class="button" id="toolEraser"><i class="fas fa-eraser"></i></button></p>
        <p class="control"><button title="Eyedropper" class="button" id="toolEyedropper"><i class="fas fa-eye-dropper"></i></button></p>
        <p class="control"><button title="Hue Brush" class="button" id="toolHueBrush"><i class="fas fa-adjust"></i></button></p>
        <p class="control"><button title="Text" class="button" id="toolText"><i class="fas fa-font"></i></button></p>
    </div>
    <label for="colorPicker">Color:</label>
    <div class="field">
        <div class="control button" onclick="colorPicker.click();">
            <input type="color" id="colorPicker" value="#ff0000">
        </div>
    </div>
    <div class="field">
        <div class="control">
            <label for="brushSize">Brush/Font Size:</label>
        </div>
    </div>
    <input class="is-primary" type="range" id="brushSize" min="1" max="16" value="1">
    <div class="field has-addons">
        <p class="control"><button title="Undo" class="button" id="undoBtn"><i class="fas fa-undo"></i></button></p>
        <p class="control"><button title="Redo" class="button" id="redoBtn"><i class="fas fa-redo"></i></button></p>
    </div>
    <div class="field has-addons">
        <p class="control"><button title="Download" class="button" id="saveBtn"><i class="fas fa-download"></i></button></p>
        <p class="control"><button title="Upload" class="button" id="loadBtn"><i class="fas fa-upload"></i></button></p>
    </div>
    <input type="file" id="fileInput" style="display:none">
</div>

<div id="canvasContainer">
    <canvas id="pixelCanvas"></canvas>
</div>

<script>
const canvas = document.getElementById('pixelCanvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('canvasContainer');

let gridWidth = 16, gridHeight = 16;
let pixelSize = 16;
let brushSize = 1;
let currentTool = 'pencil';
let currentColor = '#ff0000';
let isDrawing = false;
let startX = 0, startY = 0;
let offsetX = 0, offsetY = 0;
let scale = 1;

// Background canvas for pixel data
const bgCanvas = document.createElement('canvas');
const bgCtx = bgCanvas.getContext('2d');
bgCanvas.width = gridWidth; bgCanvas.height = gridHeight;

// Undo/Redo
let undoStack = [], redoStack = [];
function saveState() {
    redoStack = [];
    undoStack.push(bgCtx.getImageData(0,0,gridWidth,gridHeight));
    if(undoStack.length > 50) undoStack.shift();
}
function undo() {
    if(undoStack.length){
        redoStack.push(bgCtx.getImageData(0,0,gridWidth,gridHeight));
        bgCtx.putImageData(undoStack.pop(),0,0);
        render();
    }
}
function redo() {
    if(redoStack.length){
        undoStack.push(bgCtx.getImageData(0,0,gridWidth,gridHeight));
        bgCtx.putImageData(redoStack.pop(),0,0);
        render();
    }
}
document.getElementById('undoBtn').onclick = undo;
document.getElementById('redoBtn').onclick = redo;

// Checkerboard pattern
const checkerCanvas = document.createElement('canvas');
checkerCanvas.width = 16; checkerCanvas.height = 16;
const checkerCtx = checkerCanvas.getContext('2d');
checkerCtx.fillStyle = '#ccc'; checkerCtx.fillRect(0,0,8,8); checkerCtx.fillRect(8,8,8,8);
checkerCtx.fillStyle = '#fff'; checkerCtx.fillRect(8,0,8,8); checkerCtx.fillRect(0,8,8,8);
const checkerPattern = ctx.createPattern(checkerCanvas,'repeat');

// Resize canvas
function resizeCanvas(){canvas.width=container.clientWidth; canvas.height=container.clientHeight; render();}

// Draw pixel
function drawPixel(x, y, color, ctxToUse = bgCtx, center = true, sizeOverride = null) {
    const size = sizeOverride ?? brushSize;
    const half = center ? Math.floor(size / 2) : 0;

    if (color === 'eraser') {
        ctxToUse.clearRect(x - half, y - half, size, size);
    } else if (color === 'hue') {
        const imgData = ctxToUse.getImageData(x - half, y - half, size, size);
        const data = imgData.data;

        // Get the hue of the current selected color
        const tmp = document.createElement('canvas').getContext('2d');
        tmp.fillStyle = currentColor;
        tmp.fillRect(0, 0, 1, 1);
        const ref = tmp.getImageData(0, 0, 1, 1).data;
        const [targetHue] = rgbToHsl(ref[0], ref[1], ref[2]);

        for (let i = 0; i < data.length; i += 4) {
            const [h, s, l] = rgbToHsl(data[i], data[i + 1], data[i + 2]);
            const [r, g, b] = hslToRgb(targetHue, s, l);
            data[i] = r; data[i + 1] = g; data[i + 2] = b;
        }

        ctxToUse.putImageData(imgData, x - half, y - half);
    } else {
        ctxToUse.fillStyle = color;
        ctxToUse.fillRect(x - half, y - half, size, size);
    }
}

// Flood fill
function floodFill(x,y,color){
    const data=bgCtx.getImageData(0,0,gridWidth,gridHeight);
    const targetColor=[...data.data.slice((y*gridWidth+x)*4,(y*gridWidth+x)*4+4)];
    const fillColor=colorToRGBA(color);
    if(targetColor.every((v,i)=>v===fillColor[i])) return;
    const stack=[[x,y]];
    while(stack.length){
        const [cx,cy]=stack.pop();
        if(cx<0||cy<0||cx>=gridWidth||cy>=gridHeight) continue;
        const idx=(cy*gridWidth+cx)*4;
        if(data.data[idx]!==targetColor[0]||data.data[idx+1]!==targetColor[1]||data.data[idx+2]!==targetColor[2]||data.data[idx+3]!==targetColor[3]) continue;
        data.data[idx]=fillColor[0]; data.data[idx+1]=fillColor[1]; data.data[idx+2]=fillColor[2]; data.data[idx+3]=fillColor[3];
        stack.push([cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]);
    }
    bgCtx.putImageData(data,0,0);
    render();
}

// Draw rectangle ignoring brush size
function drawRect(x1,y1,x2,y2,color){
    const xmin=Math.min(x1,x2);
    const xmax=Math.max(x1,x2);
    const ymin=Math.min(y1,y2);
    const ymax=Math.max(y1,y2);
    for(let x=xmin;x<=xmax;x++)
        for(let y=ymin;y<=ymax;y++)
            drawPixel(x,y,color,bgCtx,false,1);
}

// Helpers
function colorToRGBA(str){const c=document.createElement('canvas').getContext('2d'); c.fillStyle=str; c.fillRect(0,0,1,1); return c.getImageData(0,0,1,1).data;}
function getMousePos(e){const rect=canvas.getBoundingClientRect(); const x=(e.clientX-rect.left-offsetX)/(pixelSize*scale); const y=(e.clientY-rect.top-offsetY)/(pixelSize*scale); return {x:Math.floor(x),y:Math.floor(y)};}
function getPixelColor(x,y){const data=bgCtx.getImageData(x,y,1,1).data; return `rgba(${data[0]},${data[1]},${data[2]},${data[3]/255})`;}
function rgbaToHex(rgba){const m=rgba.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),?\s*([\d.]*)\)/); if(!m)return'#000000'; const [_,r,g,b]=m; return '#'+((1<<24)+(parseInt(r)<<16)+(parseInt(g)<<8)+parseInt(b)).toString(16).slice(1);}
function rgbToHsl(r,g,b){r/=255;g/=255;b/=255;let max=Math.max(r,g,b),min=Math.min(r,g,b),h,s,l=(max+min)/2;if(max===min){h=s=0;}else{let d=max-min;s=l>0.5?d/(2-max-min):d/(max+min);switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;}h*=60;}return[h,s,l];}
function hslToRgb(h,s,l){h/=360;let r,g,b;if(s===0){r=g=b=l;}else{const hue2rgb=(p,q,t)=>{if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p;};const q=l<0.5?l*(1+s):l+s-l*s;const p=2*l-q;r=hue2rgb(p,q,h+1/3);g=hue2rgb(p,q,h);b=hue2rgb(p,q,h-1/3);}return[r*255,g*255,b*255];}

// Render
let renderScheduled=false, previewRect=null;
function render(){
    if(renderScheduled) return;
    renderScheduled=true;
    requestAnimationFrame(()=>{
        ctx.setTransform(1,0,0,1,0,0);
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.translate(offsetX,offsetY);
        ctx.scale(scale*pixelSize,scale*pixelSize);
        ctx.imageSmoothingEnabled=false;
        ctx.fillStyle=checkerPattern;
        ctx.fillRect(0,0,gridWidth,gridHeight);
        ctx.drawImage(bgCanvas,0,0,gridWidth,gridHeight,0,0,gridWidth,gridHeight);
        if(scale*pixelSize>=8){
            ctx.strokeStyle='rgba(255,255,255,0.15)';
            ctx.lineWidth=1/scale/pixelSize;
            for(let i=0;i<=gridWidth;i++){ctx.beginPath();ctx.moveTo(i,0);ctx.lineTo(i,gridHeight);ctx.stroke();}
            for(let i=0;i<=gridHeight;i++){ctx.beginPath();ctx.moveTo(0,i);ctx.lineTo(gridWidth,i);ctx.stroke();}
        }
        if(previewRect){ctx.fillStyle=currentColor+'55'; ctx.fillRect(previewRect.x,previewRect.y,previewRect.w,previewRect.h);}
        renderScheduled=false;
    });
}

// Interaction
let isPanning=false, lastX=0,lastY=0;

function getEventPos(e){
    if(e.touches && e.touches.length>0) return {clientX:e.touches[0].clientX, clientY:e.touches[0].clientY};
    else if(e.changedTouches && e.changedTouches.length>0) return {clientX:e.changedTouches[0].clientX, clientY:e.changedTouches[0].clientY};
    else return {clientX:e.clientX, clientY:e.clientY};
}

function handleStart(e){
    e.preventDefault();
    const evtPos = getEventPos(e);
    if(currentTool==='move' || e.button===1){
        isPanning=true; lastX=evtPos.clientX; lastY=evtPos.clientY; canvas.style.cursor='move'; return;
    }
    const pos = getMousePos(evtPos);
    startX=pos.x; startY=pos.y; isDrawing=true;
    if(['pencil','eraser','fill','rect','hue','text'].includes(currentTool)) saveState();
    if(currentTool==='pencil') drawPixel(pos.x,pos.y,currentColor,bgCtx);
    else if(currentTool==='eraser') drawPixel(pos.x,pos.y,'eraser',bgCtx);
    else if(currentTool==='fill') floodFill(pos.x,pos.y,currentColor);
    else if(currentTool==='eyedropper'){const c=getPixelColor(pos.x,pos.y); currentColor=c; document.getElementById('colorPicker').value=rgbaToHex(c);}
    else if(currentTool==='text'){const text=prompt('Enter text:'); if(text){bgCtx.fillStyle=currentColor; bgCtx.font=`${brushSize}px sans-serif`; bgCtx.textBaseline='top'; bgCtx.fillText(text,pos.x,pos.y); render();}}
}

function handleMove(e){
    e.preventDefault();
    const evtPos=getEventPos(e);
    if(isPanning){offsetX+=evtPos.clientX-lastX; offsetY+=evtPos.clientY-lastY; lastX=evtPos.clientX; lastY=evtPos.clientY; render(); return;}
    if(!isDrawing) return;
    const pos=getMousePos(evtPos);
    if(['pencil','eraser','hue'].includes(currentTool)){
        const dx=pos.x-startX, dy=pos.y-startY;
        const steps=Math.max(1,Math.ceil(Math.sqrt(dx*dx+dy*dy)*2));
        for(let i=0;i<=steps;i++){
            const t=i/steps;
            const ix=Math.round(startX+dx*t), iy=Math.round(startY+dy*t);
            if(currentTool==='pencil') drawPixel(ix,iy,currentColor,bgCtx);
            else if(currentTool==='eraser') drawPixel(ix,iy,'eraser',bgCtx);
            else if(currentTool==='hue') drawPixel(ix,iy,'hue',bgCtx);
        }
        startX=pos.x; startY=pos.y;
    } else if(currentTool==='rect'){
        const x = Math.min(startX, pos.x);
        const y = Math.min(startY, pos.y);
        const w = Math.abs(pos.x - startX) + 1;
        const h = Math.abs(pos.y - startY) + 1;
        previewRect = {x, y, w, h};
    }
    render();
}

function handleEnd(e){
    e.preventDefault();
    if(currentTool==='rect' && previewRect){
        const pos=getMousePos(getEventPos(e));
        drawRect(startX,startY,pos.x,pos.y,currentColor);
        previewRect=null;
    }
    isDrawing=false; isPanning=false;
    render();
}

canvas.addEventListener('mousedown',handleStart);
canvas.addEventListener('mousemove',handleMove);
canvas.addEventListener('mouseup',handleEnd);
canvas.addEventListener('touchstart',handleStart,{passive:false});
canvas.addEventListener('touchmove',handleMove,{passive:false});
canvas.addEventListener('touchend',handleEnd,{passive:false});
canvas.addEventListener('touchcancel',handleEnd,{passive:false});

// Toolbar
const toolButtons={
    move:document.getElementById('toolMove'),
    pencil:document.getElementById('toolPencil'),
    rect:document.getElementById('toolRect'),
    fill:document.getElementById('toolFill'),
    eraser:document.getElementById('toolEraser'),
    eyedropper:document.getElementById('toolEyedropper'),
    hue:document.getElementById('toolHueBrush'),
    text:document.getElementById('toolText')
};

function selectTool(tool){
    currentTool=tool;
    Object.keys(toolButtons).forEach(t=>toolButtons[t].classList.toggle('is-link',t===tool));
    canvas.style.cursor=(currentTool==='move')?'move':'crosshair';
}
toolButtons.pencil.onclick=()=>selectTool('pencil');
toolButtons.rect.onclick=()=>selectTool('rect');
toolButtons.fill.onclick=()=>selectTool('fill');
toolButtons.eraser.onclick=()=>selectTool('eraser');
toolButtons.eyedropper.onclick=()=>selectTool('eyedropper');
toolButtons.hue.onclick=()=>selectTool('hue');
toolButtons.text.onclick=()=>selectTool('text');
toolButtons.move.onclick=()=>selectTool('move');

document.getElementById('colorPicker').onchange=e=>currentColor=e.target.value;
document.getElementById('brushSize').oninput=e=>{brushSize=parseInt(e.target.value);};

// Zoom
canvas.addEventListener('wheel', e=>{
    e.preventDefault();
    if(e.ctrlKey || e.metaKey){
        const mx=e.clientX-canvas.getBoundingClientRect().left-offsetX;
        const my=e.clientY-canvas.getBoundingClientRect().top-offsetY;
        const zoomFactor=1+(-e.deltaY*0.0025);
        const newScale=Math.min(Math.max(scale*zoomFactor,0.06),64);
        offsetX-=mx*(newScale/scale-1);
        offsetY-=my*(newScale/scale-1);
        scale=newScale; render();
    } else {
        offsetX-=e.deltaX; offsetY-=e.deltaY; render();
    }
},{passive:false});

// Save/load
function saveProject(){const c=document.createElement('canvas');c.width=gridWidth;c.height=gridHeight;const cx=c.getContext('2d');cx.imageSmoothingEnabled=false;cx.drawImage(bgCanvas,0,0,gridWidth,gridHeight);return c.toDataURL('image/png');}
function loadProject(base64){const img=new Image();img.onload=()=>{gridWidth=img.width; gridHeight=img.height; bgCanvas.width=gridWidth; bgCanvas.height=gridHeight; bgCtx.clearRect(0,0,gridWidth,gridHeight); bgCtx.drawImage(img,0,0,gridWidth,gridHeight); resizeCanvas();}; img.src=base64;}
document.getElementById('saveBtn').onclick=()=>{const data=saveProject(); const a=document.createElement('a'); a.href=data; a.download='image.png'; a.click();}
document.getElementById('loadBtn').onclick=()=>{document.getElementById('fileInput').click();}
document.getElementById('fileInput').onchange=e=>{const f=e.target.files[0]; if(!f) return; const reader=new FileReader(); reader.onload=evt=>loadProject(evt.target.result); reader.readAsDataURL(f);}

// Init
resizeCanvas();
window.addEventListener('resize',resizeCanvas);
render();

document.querySelectorAll('input[type="range"]').forEach(slider => {
    slider.addEventListener('input', () => {
        const val = ((slider.value - slider.min) / (slider.max - slider.min)) * 100;
        slider.style.setProperty('--value', val + '%');
    });
    // initialize
    slider.dispatchEvent(new Event('input'));
});
</script>

</body>
</html>
